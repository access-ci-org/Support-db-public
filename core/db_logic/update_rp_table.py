import json
from pprint import pp
from . import Records
from .. import custom_halo
from ..models import db_operation, db_proxy as db
from ..models.rps import RPS
from peewee import *

def get_rp_info(rp_groups_file: str = "data/rp_groups.json"):
    """ """
    # The data in 'data/rp_groups.json' is generated by the 'import_operations_data' function in reset_database.py
    with open(rp_groups_file, "r", encoding="utf-8") as rgf:
        all_rp_data = json.load(rgf)

    rp_data = []

    for resource in all_rp_data["results"]["resources"]:
        data = {}
        if resource["cider_type"] == "Compute" or resource["cider_type"] == "Storage":
            data.update(
                {
                    "resource_id": resource["info_resourceid"],
                    "name": resource["resource_descriptive_name"],
                }
            )
        for group in all_rp_data["results"]["active_groups"]:
            if data and resource["info_resourceid"] in group["rollup_info_resourceids"]:
                data.update({"group_id": group["info_groupid"]})
                break
        if data:
            rp_data.append(data)
    return rp_data


def create_rp_table_records():
    """Creates list of dictionaries for RPS table records."""
    records = []
    rp_data = get_rp_info()
    for rp in rp_data:
        resource_id = rp["resource_id"]
        group_id = rp["group_id"]
        if "bridges" in group_id:
            rp_name = "bridges-2"
        else:
            rp_name = group_id.split(".")[0]

        records.append(
            {"rp_name": rp_name, "rp_group_id": group_id, "rp_resource_id": resource_id}
        )

    return records


@custom_halo(text="Updating RP table")
@db_operation("edit")
def update_rp_table(rp_records: Records):
    """Adds data to the RPS table based on provided rp_records.

    In cases where the rp_name is already in the table, it updates the data for
    that row.

    Args:
        rp_records (Records): Records where each key in the dict is a column in
            the RPS table (returned from `create_rp_table_records()`)
    """
    with db.atomic():
        for batch in rp_records:  # Safe for large inserts
            RPS.insert_many(batch).on_conflict(
                conflict_target=[RPS.rp_resource_id],
                update={
                    RPS.rp_name: EXCLUDED.rp_name,
                    RPS.rp_group_id: EXCLUDED.rp_group_id,
                },
            ).execute()


if __name__ == "__main__":
    pass
